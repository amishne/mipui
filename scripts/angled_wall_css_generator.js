const out = process.stdout;

const beigeLandParams = {
  fillColor: 'rgb(222, 184, 135)',
  strokeColor: 'bisque'
};
const graphPaperParams = {
  fillColor: 'rgb(210, 210, 210)',
  strokeColor: 'rgb(183, 195, 199)'
};
const cutoutParams = {
  fillColor: 'rgb(205, 222, 222)',
  strokeColor: 'rgb(205, 222, 222)'
};

const params = cutoutParams;

/*
// An angled cell is composed of 17 parts (uppercase letters):

 0  7  14 19 2431 38
 v  v  v  v  v v  v
--------------------
|tl|\     t    /|tr| < 0
|  |A\        /B|  |
--------------------
|\C|   \  D /   |E/| < 7
| \|    \  /    |/ |
|  | F   \/   G |  | < 14
|  |\    /\    /|  | < 12
|  | \  /  \  / |  |
|l |H \/  I \/ J| r|
|  |  /\    /\  |  | < 19
|  | /  \  /  \ |  |
|  |/    \/    \|  | < 26
|  |  K  /\  L  \  | < 24
| /|    /  \    |\ |
|/M|   /  N \   |O\| < 31
--------------------
|  |P/        \Q|  |
|bl|/     b    \|br| < 38
--------------------

The 8 potential connections (lowercase letters) control which parts are walls
and which aren't; sectionsFromDirs contains the logic.
*/

function emitLines(section) {
  let l = [];
  switch (section) {
    case 'A': l = ['7 6.5, 13 6.5']; break;
    case 'B': l = ['25 6.5, 32 6.5', '31.5 0, 31.5 7']; break;
    case 'C': l = ['6.5 7, 6.5 13']; break;
    case 'G': l = ['31.5 7, 31.5 13']; break;
    case 'J': l = ['31.5 14, 31.5 24']; break;
    case 'K': l = ['7 31.5, 13 31.5']; break;
    case 'L': l = ['31.5 25, 31.5 32', '25 31.5, 32 31.5']; break;
    case 'M': l = ['6.5 25, 6.5 32', '0 31.5, 7 31.5']; break;
    case 'N': l = ['14 31.5, 24 31.5']; break;
    case 'O': l = ['32 31.5, 39 31.5']; break;
    case 'Q': l = ['31.5 32, 31.5 39']; break;
  }
  l.forEach(points => {
    const [[x1, y1], [x2, y2]] =
        points.split(',').map(s => s.trim()).map(s => s.split(' '));
    out.write(`<line stroke-linecap='round' x1='${x1}' y1='${y1}' x2='${x2}' y2='${y2}' />`);
  });
}

function emitPolygon(section) {
  let p = null;
  switch (section) {
    case 'A': p = '7 0, 14 7, 7 7'; break;
    case 'B': p = '31 0, 31 7, 24 7'; break;
    case 'C': p = '0 7, 7 7, 7 14'; break;
    case 'D': p = '14 7, 24 7, 19 12'; break;
    case 'E': p = '31 7, 38 7, 31 14'; break;
    case 'F': p = '7 7, 14 7, 19 12, 12 19, 7 14'; break;
    case 'G': p = '24 7, 31 7, 31 14, 26 19, 19 12'; break;
    case 'H': p = '7 14, 12 19, 7 24'; break;
    case 'I': p = '19 12, 26 19, 19 26, 12 19'; break;
    case 'J': p = '31 14, 31 24, 26 19'; break;
    case 'K': p = '12 19, 19 26, 14 31, 7 31, 7 24'; break;
    case 'L': p = '26 19, 31 24, 31 31, 24 31, 19 26'; break;
    case 'M': p = '7 24, 7 31, 0 31'; break;
    case 'N': p = '19 26, 24 31, 14 31'; break;
    case 'O': p = '31 24, 38 31, 31 31'; break;
    case 'P': p = '7 31, 14 31, 7 38'; break;
    case 'Q': p = '24 31, 31 31, 31 38'; break;
  }
  out.write(`<polygon points='${p}' />`);
}

function sectionsFromDirs(d) {
  const sections = [];
  const s = sectionName => {
    sections.push(sectionName);
  };
  s('I');
  if (d.t) s('D');
  if (d.r) s('J');
  if (d.b) s('N');
  if (d.l) s('H');
  if (d.tl || d.t || d.l) s('F');
  if (d.tr || d.t || d.r) s('G');
  if (d.br || d.b || d.r) s('L');
  if (d.bl || d.b || d.l) s('K');
  if (d.tl && !d.l) s('C');
  if (d.tl && !d.t) s('A');
  if (d.tr && !d.t) s('B');
  if (d.tr && !d.r) s('E');
  if (d.br && !d.r) s('O');
  if (d.br && !d.b) s('Q');
  if (d.bl && !d.b) s('P');
  if (d.bl && !d.l) s('M');
  return sections;
}

function emitClassForConnections(connections) {
  console.log(`\n.angled-wall-cell-${connections} {`);
  out.write('  background: url("');
  emitSvgBackground(connections);
  console.log('");\n}');
}

function emitSvgBackground(connections) {
  out.write(`data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='40' height='40' shape-rendering='crispEdges'><style>polygon {fill: ${params.fillColor};} line {stroke-width: 1; stroke: ${params.strokeColor};}</style>`);
  const directions = {
    't': 1,
    'r': 2,
    'b': 4,
    'l': 8,
    'tr': 16,
    'br': 32,
    'bl': 64,
    'tl': 128
  };
  const d = {};
  Object.keys(directions).forEach(key => {
    d[key] = (connections & directions[key]) != 0;
  });
  emitSvgPolygons(d);
  emitSvgLines(d);
  out.write('</svg>');
}

function emitSvgPolygons(d) {
  const sections = sectionsFromDirs(d);
  // Two separate loops because we want all polygons preceding all lines, for
  // layering.
  sections.forEach(section => {
    emitPolygon(section);
  });
  sections.forEach(section => {
    emitLines(section);
  });
}

function emitSvgLines(d) {

}

console.log('/* Automatically generated by scripts/angled_wall_css_generator.js */');
for (let connections = 0; connections < 256; connections++) {
  emitClassForConnections(connections);
}
